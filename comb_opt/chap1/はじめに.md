# 始めに

### 練習1.1  ドリル穴開け問題

- インスタンス：平面上のn個の点  $p_1, p_2, ..., p_n \in R^2$ 
- タスク $\sum_{ i = 1 } ^ { n - 1} d(p_{\pi(i)}, p_{\pi(i+1)})$　が最小となるような順列 $\pi = \colon \{1, ... , n \} \Rightarrow \{1, ... , n \}$ を求める。

### 問題1.2 ジョブ割り当て問題
- インスタンス：n個のジョブ実装時間 $t_1,..., t_n \in R_+$ , $m \in N$ 人の従業員、および各ジョブ $i\in\{1,..,n\}$ に対する担当可換で空でない従業員の部分集合 $S_i\subseteq\{1,...,n\}$
- 全ての $i\in\{1,..,n\}$で、$\sum_{j\in S_i} x_{ij} = t_i$を満たす$x_{ij} \in R_+$ のうちで $max_{j\in\{1,...,m\}} \sum_{i:j\in S_i} x_{ij}$が最小となるような$x_{ij} \in R_+$ を求める

## 1.1 列挙
n個の点があればn!通りの全ての順列を求めて最小の物を出力する。
  
### 定義1.1
> $x,y\in R^n$ を2つのベクトルとする。全てのi=1,..j-1で$xi = y_i$であり、かつ$x_j< y_j$となるような添え字$j \in \{1,...n\}$ が存在するとき、ベクトルxはベクトルyより、辞書順で小さい(lexicograpically)と呼ぶ。

列挙するアルゴリズムは $O(n^n)$だが、これは最小では無い。n個の順列の層数は$n!$であり、$n^n$よりも圧倒的に小さい。

### アルゴリズム 1.1 パス列挙アルゴリズム(Path Enumeration Algorithm)
入力：自然数 n > 3と平面上のn個の点の集合 $\{p_1, ... . p_n\}$
出力：パスの長さ
$$
cost(\pi^\ast) := \sum_{i=1}^{n-1} d(p_{\pi^\ast(i)}, p_{\pi-\ast(i+1)})
$$
が最小となる順列を求める。

```rust

use std::collections::HashSet;

type Pi = Vec<u32>;

fn calc_k(pi:&Pi, i:u32, n:u32) -> u32 {

    // pi(i) + 1 .. n
    let g0: HashSet<u32> = (pi[i as usize - 1] + 1.. n + 2).collect();
    //println!("g0 = {:?}", g0);
    // pi(1) .. pi(i-1)
    let g1: HashSet<u32> = pi[0 .. (i - 1) as usize].to_vec().into_iter().collect();    
    //println!("g1 = {:?}", g1);

    let diff = &g0 - &g1;
    match diff.into_iter().min() {
        Some(k) => k,
        _ => 0
    }   
}

fn enumlation(n: u32) -> Vec<Pi> {
    let mut pi : Pi = (1..n+1).collect();
    let mut i = n - 1;  
    let mut result :  Vec<Vec<u32>> = Vec::new();
    let mut k = calc_k(&pi, i , n);

    result.push(pi.clone());

    // k == n + 1, i == 1
    while k != n + 1 || i != 1  {
        if k <= n {
            pi[i as usize - 1] = k;
            if i == n {
                result.push(pi.clone());
            }
            if i < n  {
                pi[i as usize] = 0;
                i = i + 1;
            }
        }
        if k == n + 1 {
            i = i - 1;
        }
        k = calc_k(&pi, i , n);
    }
    
    result
        
}

#[test]
fn test_k() {
    assert_eq!(calc_k(&vec![1,2,3,4,5,6], 5, 6), 6);
    assert_eq!(calc_k(&vec![1,2,3,4,6,5], 5, 6), 7);
    assert_eq!(calc_k(&vec![1,2,3,4,6,5], 4, 6), 5);
}


fn main() {
    let ret = enumlation(4);
    println!("len = {}", ret.len());
    println!("{:?}", ret);
}

```
