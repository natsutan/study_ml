# 始めに

### 練習1.1  ドリル穴開け問題

- インスタンス：平面上のn個の点  $p_1, p_2, ..., p_n \in R^2$ 
- タスク $\sum_{ i = 1 } ^ { n - 1} d(p_{\pi(i)}, p_{\pi(i+1)})$　が最小となるような順列 $\pi = \colon \{1, ... , n \} \Rightarrow \{1, ... , n \}$ を求める。

### 問題1.2 ジョブ割り当て問題
- インスタンス：n個のジョブ実装時間 $t_1,..., t_n \in R_+$ , $m \in N$ 人の従業員、および各ジョブ $i\in\{1,..,n\}$ に対する担当可換で空でない従業員の部分集合 $S_i\subseteq\{1,...,n\}$
- 全ての $i\in\{1,..,n\}$で、$\sum_{j\in S_i} x_{ij} = t_i$を満たす$x_{ij} \in R_+$ のうちで $max_{j\in\{1,...,m\}} \sum_{i:j\in S_i} x_{ij}$が最小となるような$x_{ij} \in R_+$ を求める

## 1.1 列挙
n個の点があればn!通りの全ての順列を求めて最小の物を出力する。
  
### 定義1.1
> $x,y\in R^n$ を2つのベクトルとする。全てのi=1,..j-1で$xi = y_i$であり、かつ$x_j< y_j$となるような添え字$j \in \{1,...n\}$ が存在するとき、ベクトルxはベクトルyより、辞書順で小さい(lexicograpically)と呼ぶ。

列挙するアルゴリズムは $O(n^n)$だが、これは最小では無い。n個の順列の層数は$n!$であり、$n^n$よりも圧倒的に小さい。

### アルゴリズム 1.1 パス列挙アルゴリズム(Path Enumeration Algorithm)
入力：自然数 n > 3と平面上のn個の点の集合 $\{p_1, ... . p_n\}$
出力：パスの長さ
$$
cost(\pi^\ast) := \sum_{i=1}^{n-1} d(p_{\pi^\ast(i)}, p_{\pi-\ast(i+1)})
$$
が最小となる順列を求める。

```rust

use std::collections::HashSet;

type Pi = Vec<u32>;

fn calc_k(pi:&Pi, i:u32, n:u32) -> u32 {

    // pi(i) + 1 .. n
    let g0: HashSet<u32> = (pi[i as usize - 1] + 1.. n + 2).collect();
    //println!("g0 = {:?}", g0);
    // pi(1) .. pi(i-1)
    let g1: HashSet<u32> = pi[0 .. (i - 1) as usize].to_vec().into_iter().collect();    
    //println!("g1 = {:?}", g1);

    let diff = &g0 - &g1;
    match diff.into_iter().min() {
        Some(k) => k,
        _ => 0
    }   
}

fn enumlation(n: u32) -> Vec<Pi> {
    let mut pi : Pi = (1..n+1).collect();
    let mut i = n - 1;  
    let mut result :  Vec<Vec<u32>> = Vec::new();
    let mut k = calc_k(&pi, i , n);

    result.push(pi.clone());

    // k == n + 1, i == 1
    while k != n + 1 || i != 1  {
        if k <= n {
            pi[i as usize - 1] = k;
            if i == n {
                result.push(pi.clone());
            }
            if i < n  {
                pi[i as usize] = 0;
                i = i + 1;
            }
        }
        if k == n + 1 {
            i = i - 1;
        }
        k = calc_k(&pi, i , n);
    }
    
    result
        
}

#[test]
fn test_k() {
    assert_eq!(calc_k(&vec![1,2,3,4,5,6], 5, 6), 6);
    assert_eq!(calc_k(&vec![1,2,3,4,6,5], 5, 6), 7);
    assert_eq!(calc_k(&vec![1,2,3,4,6,5], 4, 6), 5);
}


fn main() {
    let ret = enumlation(4);
    println!("len = {}", ret.len());
    println!("{:?}", ret);
}

```

### 定義1.2
f=O(g)かつ、g=O(f)の時、fとgは同じ増加率(rate of growth)を持つという。

## 1.2 アルゴリズムの計算時間
- 計算時間 running time
- 時間計算量 time complexity

### 定義 1.5
有理数入力に対するアルゴリズムは、ある呈すkが存在して、入力サイズnのどの入力に対しても $O(n^k)$ 時間で走り、かつ計算の途中で生じる数も全て $O(n^k)$ で記憶できるとき、多項式時間(polynomial time)で走ると言う。
有理数とは限らないn個の数のどの入力に対しても、  $O(n^k)$ 時間で走り、かつ有理数入力に対しても他項時間で走るとき、強多項式時間(strongly polynomial time)で走ると言う。k=1の時、線形時間アルゴリズム(liner-time algorithm)という。強多項式時間でない、多項式時間のアルゴリズムは弱多項式時間(weakly polynominal time)と呼ばれる。

## 1.3 線形の最適化問題
ジョブ割り当て問題は実行可能性が無限個ある。全てが終わる時刻をTとして

$min \quad T$

$\sum _{j \in S_i} x_{ij} = t_i \qquad (i \in \{1, ..., n\})$

$x_{ij} \gt 0\quad (i\in \{1,...,n\}, j\in S_i)$

$\sum _{i:j \in S_i} x_{ij} \lt T  \qquad (j \in \{1, ..., m\})$

線形の目的関数と線形の制約式を持つ最適化問題を線形計画問題(linear program)と呼ばれる。解の集合は多面体(Polyhedron)と呼ばれ、最適解が存在するときは有限個の端点を列挙することで解ける。

グラフで解く。（2章と3章）

## 1.4 ソーティング
ドリル問題が1直線上であれば、座標の小さい順でソートして左から動かせば良い。




